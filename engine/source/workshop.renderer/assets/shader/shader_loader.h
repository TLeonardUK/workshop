// ================================================================================================
//  workshop
//  Copyright (C) 2021 Tim Leonard
// ================================================================================================
#pragma once

#include "workshop.assets/asset_loader.h"
#include "workshop.renderer/assets/shader/shader.h"

namespace ws {

class asset;
class shader;
class render_interface;
class ri_interface;
class renderer;

// ================================================================================================
//  Loads shaders files.
// 
//  Shader files contain a description of the param blocks, render state, techniques
//  and other associated rendering data required to use a shader as part of
//  a render pass. It is not just a shader on its own.
// ================================================================================================
class shader_loader : public asset_loader
{
public:
    shader_loader(ri_interface& instance, renderer& renderer);

    virtual const std::type_info& get_type() override;
    virtual const char* get_descriptor_type() override;
    virtual asset* get_default_asset() override;
    virtual asset* load(const char* path) override;
    virtual void unload(asset* instance) override;
    virtual bool compile(const char* input_path, const char* output_path, platform_type asset_platform, config_type asset_config, asset_flags flags) override;
    virtual void hot_reload(asset* instance, asset* new_instance) override;
    virtual bool can_hot_reload() override { return true; };
    virtual size_t get_compiled_version() override;

private:
    bool serialize(const char* path, shader& asset, bool isSaving);

    std::string create_autogenerated_stub(shader::technique& technique, shader& asset);

    bool save(const char* path, shader& asset);

    bool compile_shader_stage(const char* path, shader::technique& technique, shader& asset, platform_type asset_platform, config_type asset_config, shader::shader_stage& stage, ri_shader_stage pipeline_stage);
    bool compile_technique(const char* path, shader::technique& technique, shader& asset, platform_type asset_platform, config_type asset_config);
    bool compile_ray_hitgroup(const char* path, shader::technique& technique, shader::ray_hitgroup& hitgroup, shader& asset, platform_type asset_platform, config_type asset_config);

    bool parse_imports(const char* path, YAML::Node& node, shader& asset);

    bool parse_defines(const char* path, YAML::Node& node, shader& asset);

    bool parse_param_blocks(const char* path, YAML::Node& node, shader& asset);
    bool parse_param_block(const char* path, const char* name, YAML::Node& node, shader& asset);

    bool parse_ray_hitgroups(const char* path, YAML::Node& node, shader& asset);
    bool parse_ray_hitgroup(const char* path, const char* name, YAML::Node& node, shader& asset);

    bool parse_render_states(const char* path, YAML::Node& node, shader& asset);
    bool parse_render_state(const char* path, const char* name, YAML::Node& node, shader& asset);

    bool parse_variations(const char* path, YAML::Node& node, shader& asset);
    bool parse_variation(const char* path, const char* name, YAML::Node& node, std::vector<shader::variation>& variations);

    bool parse_vertex_layouts(const char* path, YAML::Node& node, shader& asset);
    bool parse_vertex_layout(const char* path, const char* name, YAML::Node& node, shader& asset);

    bool parse_output_targets(const char* path, YAML::Node& node, shader& asset);
    bool parse_output_target(const char* path, const char* name, YAML::Node& node, shader& asset);

    bool parse_shader_stages(const char* path, const char* name, YAML::Node& node, shader& asset, std::array<shader::shader_stage, static_cast<int>(ri_shader_stage::COUNT)>& stages, size_t& loaded_stage_count);

    bool parse_techniques(const char* path, YAML::Node& node, shader& asset);
    bool parse_technique(const char* path, const char* name, YAML::Node& node, shader& asset);

    bool parse_effects(const char* path, YAML::Node& node, shader& asset);
    bool parse_effect(const char* path, const char* name, YAML::Node& node, shader& asset);

    bool parse_file(const char* path, shader& asset);

private:
    ri_interface& m_ri_interface;
    renderer& m_renderer;

};

}; // namespace workshop
