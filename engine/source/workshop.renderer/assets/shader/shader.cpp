// ================================================================================================
//  workshop
//  Copyright (C) 2021 Tim Leonard
// ================================================================================================
#include "workshop.renderer/assets/shader/shader.h"
#include "workshop.renderer/assets/material/material.h"
#include "workshop.render_interface/ri_interface.h"
#include "workshop.render_interface/ri_pipeline.h"
#include "workshop.renderer/renderer.h"
#include "workshop.renderer/render_effect.h"
#include "workshop.renderer/render_effect_manager.h"
#include "workshop.renderer/render_param_block_manager.h"

namespace ws {

shader::shader(ri_interface& ri_interface, renderer& renderer)
    : m_ri_interface(ri_interface)
    , m_renderer(renderer)
{
}

shader::~shader()
{
    unregister_effects();
}

void shader::unregister_effects()
{
    for (param_block& instance : param_blocks)
    {
        if (instance.renderer_id)
        {
            m_renderer.get_param_block_manager().unregister_param_block_archetype(instance.renderer_id);
            instance.renderer_id = 0;
        }
    }

    for (effect& instance : effects)
    {
        if (instance.renderer_id)
        {
            m_renderer.get_effect_manager().unregister_effect(instance.renderer_id);
            instance.renderer_id = 0;
        }
    }
}

std::unique_ptr<ri_pipeline> shader::make_technique_pipeline(const technique& instance)
{
    ri_pipeline::create_params params;
    params.vertex_layout = vertex_layouts[instance.vertex_layout_index].layout;
    params.render_state = render_states[instance.render_state_index].state;

    output_target& target = output_targets[instance.output_target_index];
    params.depth_format = target.depth;
    params.color_formats = target.color;

    // Note: If you modify, update the auto-generated code 
    //       in shader_loader::create_autogenerated_stub.
    params.descriptor_tables.push_back(ri_descriptor_table::texture_1d);
    params.descriptor_tables.push_back(ri_descriptor_table::texture_2d);
    params.descriptor_tables.push_back(ri_descriptor_table::texture_3d);
    params.descriptor_tables.push_back(ri_descriptor_table::texture_cube);
    params.descriptor_tables.push_back(ri_descriptor_table::sampler);
    params.descriptor_tables.push_back(ri_descriptor_table::buffer);
    params.descriptor_tables.push_back(ri_descriptor_table::rwbuffer);
    params.descriptor_tables.push_back(ri_descriptor_table::rwtexture_2d);
    params.descriptor_tables.push_back(ri_descriptor_table::tlas);

    for (size_t block_index : instance.param_block_indices)
    {
        param_block& block = param_blocks[block_index];

        ri_param_block_archetype* archetype = m_renderer.get_param_block_manager().get_param_block_archetype(block.renderer_id);
        db_assert(archetype != nullptr);

        params.param_block_archetypes.push_back(archetype);
    }

    for (size_t i = 0; i < instance.stages.size(); i++)
    {
        params.stages[i].bytecode = instance.stages[i].bytecode;
        params.stages[i].entry_point = instance.stages[i].entry_point;
        params.stages[i].file = instance.stages[i].file;
    }

    for (const ray_missgroup& group : instance.ray_missgroups)
    {
        ri_pipeline::create_params::ray_missgroup& param_group = params.ray_missgroups.emplace_back();
        param_group.type = (size_t)group.type;
        param_group.name = group.name.c_str();

        param_group.ray_miss_stage.bytecode = group.ray_miss_stage.bytecode;
        param_group.ray_miss_stage.entry_point = group.ray_miss_stage.entry_point;
        param_group.ray_miss_stage.file = group.ray_miss_stage.file;
    }

    for (const ray_hitgroup& group : instance.ray_hitgroups)
    {
        ri_pipeline::create_params::ray_hitgroup& param_group = params.ray_hitgroups.emplace_back();
        param_group.domain = (size_t)group.domain;
        param_group.type = (size_t)group.type;
        param_group.name = group.name.c_str();

        for (size_t i = 0; i < group.stages.size(); i++)
        {
            param_group.stages[i].bytecode = group.stages[i].bytecode;
            param_group.stages[i].entry_point = group.stages[i].entry_point;
            param_group.stages[i].file = group.stages[i].file;
        }
    }

    std::unique_ptr<ri_pipeline> pipeline = m_ri_interface.create_pipeline(params, instance.name.c_str());
    if (pipeline == nullptr)
    {
        db_error(asset, "Failed to create pipeline for technique '%s' in shader '%s'.", instance.name.c_str(), name.c_str());
        return nullptr;
    }

    return pipeline;
}

bool shader::load_dependencies()
{
    for (param_block& instance : param_blocks)
    {
        instance.renderer_id = m_renderer.get_param_block_manager().register_param_block_archetype(instance.name.c_str(), instance.scope, instance.layout);
        if (instance.renderer_id == 0)
        {
            db_error(asset, "Failed to create param block archetype '%s' for shader '%s'.", instance.name.c_str(), name.c_str());
            return false;
        }
    }

    // Create render effect instances.
    for (effect& instance : effects)
    {
        std::unique_ptr<render_effect> effect = std::make_unique<render_effect>();
        effect->name = instance.name;

        for (effect::technique& instance : instance.techniques)
        {
            std::unique_ptr<render_effect::technique> tech = std::make_unique<render_effect::technique>();
            tech->name = instance.name;
            
            for (variation& var : instance.variations)
            {
                render_effect::variation_parameter& param = tech->variation_parameters.emplace_back();
                param.name = var.name;
                param.values = var.values;
            }

            auto iter = std::find_if(techniques.begin(), techniques.end(), [&instance](const technique& value) {
                return value.name == instance.name;
            });

            if (iter == techniques.end())
            {
                db_fatal(asset, "Failed to find appropriate technique data for effect technique. This shouldn't be possible, check shader_loader for bugs!");
                return false;
            }

            tech->pipeline = make_technique_pipeline(*iter);
            tech->defines = iter->defines;

            // Merge in global defines.
            for (auto& pair : global_defines)
            {
                tech->defines[pair.first] = pair.second;
            }

            effect->techniques.push_back(std::move(tech));
        }

        instance.renderer_id = m_renderer.get_effect_manager().register_effect(std::move(effect));
    }

    return true;
}

void shader::swap(shader* other)
{
    // Swap the raw data around.
    std::swap(param_blocks, other->param_blocks);
    std::swap(render_states, other->render_states);
    std::swap(render_states, other->render_states);
    std::swap(variations, other->variations);
    std::swap(vertex_layouts, other->vertex_layouts);
    std::swap(output_targets, other->output_targets);
    std::swap(effects, other->effects);
    std::swap(techniques, other->techniques);
    std::swap(global_defines, other->global_defines);

    // Throw a warning if the param blocks drastically differ
    // changing these in a hot reload is complicated to support, so its better
    // to just tell the user to reboot at this point.
    bool param_blocks_different = false;
    if (param_blocks.size() != other->param_blocks.size())
    {
        param_blocks_different = true;
    }
    else
    {
        for (size_t i = 0; i < param_blocks.size(); i++)
        {
            param_block& pb = param_blocks[i];
            param_block& other_pb = other->param_blocks[i];

            if (pb.name != other_pb.name ||
                pb.scope != other_pb.scope ||
                pb.layout != other_pb.layout)
            {
                param_blocks_different = true;
                break;
            }
        }
    }

    if (param_blocks_different)
    {
        db_warning(renderer, "Changing param block configuration through hot reloading is very dangerous. Game may be unstable beyond this point.");
    }

    // Swap archetype internals
    for (param_block& instance : param_blocks)
    {
        // Fidn the old state.
        for (param_block& old_instance : other->param_blocks)
        {
            if (old_instance.name == instance.name)
            {
                // We want to preserve the old id to keep everything linked up.
                std::swap(instance.renderer_id, old_instance.renderer_id);

                // Swap the contents of the param block archetype.
                m_renderer.get_param_block_manager().swap_param_block_archetype(instance.renderer_id, old_instance.renderer_id);
            }
        }
    }

    // Swap effect internals.
    for (effect& instance : effects)
    {
        for (effect& old_instance : other->effects)
        {
            // We want to preserve the old id to keep everything linked up.
            std::swap(instance.renderer_id, old_instance.renderer_id);

            // Swap the contents of the param block archetype.
            m_renderer.get_effect_manager().swap_effect(instance.renderer_id, old_instance.renderer_id);
        }
    }

    // Nuke the old assets immediately rather than waiting for them to 
    // be unloaded. Avoids the duplicating causing conflicts anywhere.
    other->unregister_effects();
}

}; // namespace ws
