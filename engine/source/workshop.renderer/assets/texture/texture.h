// ================================================================================================
//  workshop
//  Copyright (C) 2021 Tim Leonard
// ================================================================================================
#pragma once

#include "workshop.assets/asset.h"
#include "workshop.core/containers/string.h"
#include "workshop.core/drawing/pixmap.h"

#include "workshop.render_interface/ri_types.h"

#include "workshop.renderer/renderer.h"
#include <array>
#include <unordered_map>

namespace ws {

class asset;
class ri_interface;
class renderer;
class pixmap;

// ================================================================================================
//  Defines how a texture is intended to be used. This is used to determine how
//  the data is compressed and loaded.
// ================================================================================================
enum class texture_usage
{
    color,          // 3/4 channel color map
    normal,         // 2 channel (RG) normal map
    roughness,      // 1 channel (R) mask
    metallic,       // 1 channel (R) mask
    mask,           // 1 channel (R) mask

    COUNT
};

inline static const char* texture_usage_strings[static_cast<int>(texture_usage::COUNT)] = {
    "color",
    "normal",
    "roughness",
    "metallic",
    "mask"
};

DEFINE_ENUM_TO_STRING(texture_usage, texture_usage_strings)

// ================================================================================================
//  Defines how individual channels in a texture can be modified.
// ================================================================================================
enum class texture_channel_flags
{
    none    = 0,

    invert  = 1  // Value should be inverted. This is mainly beneficial for normal maps which use the wrong tangent basis.
};

DEFINE_ENUM_FLAGS(texture_channel_flags)

// ================================================================================================
//  Texture assets represent a single individual multidimensional texture.
// ================================================================================================
class texture : public asset
{
public:
    struct face
    {
        std::string file;
        std::vector<std::unique_ptr<pixmap>> mips;
    };

public:
    texture(ri_interface& ri_interface, renderer& renderer);
    virtual ~texture();

    void swap(texture* other);

public:
    texture_usage usage = texture_usage::color;
    ri_texture_dimension dimensions = ri_texture_dimension::COUNT;
    pixmap_format format = pixmap_format::COUNT;
    size_t width = 0;
    size_t height = 0;
    size_t depth = 0;
    bool mipmapped = true;
    std::vector<face> faces;

    // Tightly packed data as generated by the ri_texture_compiler for
    // the current data layout.
    size_t mip_levels = 0;
    std::vector<uint8_t> data;

    // Only used at compile time.
    std::array<size_t, 4> swizzle = { 0, 1, 2, 3 };
    std::array<texture_channel_flags, 4> channel_flags = { texture_channel_flags::none, texture_channel_flags::none, texture_channel_flags::none, texture_channel_flags::none };

    std::unique_ptr<ri_texture> ri_instance;

protected:
    virtual bool load_dependencies() override;

private:
    ri_interface& m_ri_interface;
    renderer& m_renderer;

};

}; // namespace workshop
