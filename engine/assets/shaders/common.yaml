# ================================================================================================
#  workshop
#  Copyright (C) 2022 Tim Leonard
# ================================================================================================
# This file just contains commonly used structures which are generic to specific shaders.
# ================================================================================================
type: shader
version: 1

render_states:
  # Default geometry rendering state.
  default: 
    cull_mode: none
  # Default geometry rendering state that is used for rendering depth only data - shadow maps etc.
  depth_only_render_state: 
    cull_mode: none
    depth_clip_enabled: false
  # Default geometry rendering state in wireframe.
  default_wireframe: 
    cull_mode: none
    fill_mode: wireframe 
  # Default render state but without depth testing enabled. Useful
  # for things such as fullscreen passes.
  no_depth_test:
    depth_test_enabled: false  
    depth_write_enabled: true
    cull_mode: none
  # Default render state but without depth testing enabled. Useful
  # for things such as fullscreen passes.
  passthrough_render_state:
    cull_mode: back
    depth_test_enabled: false  
    depth_write_enabled: false
    depth_clip_enabled: false
    blend0_enabled: false
  # Transparent geometry rendering state.
  transparent: 
    cull_mode: none  
    depth_write_enabled: false
    blend0_enabled: true
    blend0_op: add
    blend0_source_op: source_alpha
    blend0_destination_op: inverse_source_alpha
    blend0_alpha_op: add
    blend0_alpha_source_op: zero
    blend0_alpha_destination_op: one
  # Transparent without depth testing. Useful for blending post-processes.
  transparent_no_depth_test: 
    cull_mode: none  
    depth_test_enabled: false
    depth_write_enabled: false
    blend0_enabled: true
    blend0_op: add
    blend0_source_op: source_alpha
    blend0_destination_op: inverse_source_alpha
    blend0_alpha_op: add
    blend0_alpha_source_op: zero
    blend0_alpha_destination_op: one
  # Render state for raytracing the scene.
  raytrace_scene_render_state:
    max_rt_payload_size: 48 

vertex_layouts:
  # Simple layout that contains only vert position and uv. Useful
  # for things like fullscreen passes.
  vertex2d_pos_uv: [ position, uv0 ]
  # Standard layout for geometry vertices
  geometry_vertex: [ position, normal, tangent, uv0 ]

output_targets:
  # Main gbuffer target with all MRT targets.
  gbuffer:
    #color: [ R16G16B16A16, R32G32B32A32_FLOAT, R32G32B32A32_FLOAT, R32G32B32A32_FLOAT ]
    color: [ R16G16B16A16_FLOAT, R16G16B16A16_FLOAT, R32G32B32A32_FLOAT ]
    depth: D24_UNORM_S8_UINT
  # SDR Swapchain output target.
  sdr_swapchain:
    color: [ R8G8B8A8_SRGB ]
  # SDR Swapchain output target.
  sdr_swapchain_and_depth:
    color: [ R8G8B8A8_SRGB ]
    depth: D24_UNORM_S8_UINT
  # HDR Swapchain output target.
  hdr_swapchain:
    color: [ R32G32B32A32_FLOAT ]
  # HDR Swapchain output target.
  hdr_swapchain_and_depth:
    color: [ R32G32B32A32_FLOAT ]
    depth: D24_UNORM_S8_UINT
  # Light accumulation buffer.
  light_buffer:
    color: [ R16G16B16A16_FLOAT ]
  # Light accumulation buffer & the gbuffer depth.
  light_buffer_and_depth:
    color: [ R16G16B16A16_FLOAT ]
    depth: D24_UNORM_S8_UINT
  # Depth only output
  depth_only_buffer:
    color: [ ]
    depth: D32_FLOAT
  # SSAO buffer.
  ssao_buffer:
    color: [ R16_FLOAT ] # Only needs 1 channel, 4 for debugging.

param_blocks:
  # Contains all the parameters needed to read/write from the gbuffer.
  gbuffer:
    scope: draw
    fields:
      gbuffer0_texture: texture2d
      gbuffer1_texture: texture2d
      gbuffer2_texture: texture2d
      #gbuffer3_texture: texture2d
      gbuffer_sampler: sampler
      gbuffer_dimensions: int2
  # Describes the projection information for the view being rendered.
  view_info:
    scope: draw
    fields:
      view_matrix: float4x4
      projection_matrix: float4x4
      inverse_view_matrix: float4x4
      inverse_projection_matrix: float4x4
      view_world_position: float3
      view_z_far: float
      view_z_near: float      
      view_dimensions: float2
  # Format of an instance in a buffer that contains a set of lights
  # TODO: Pack all this data down.
  light_state:
    scope: indirect
    fields:
      type: int
      position: float3
      direction: float3
      color: float3
      intensity: float
      inner_radius: float
      outer_radius: float
      range: float
      shadow_map_start_index: int
      shadow_map_count: int
      cascade_blend_factor: float
      importance_distance: float
  # Format of an instance in a buffer that contains a set of shadow maps
  shadow_map_state:
    scope: indirect
    fields:
      shadow_matrix: float4x4
      depth_map: texture2d
      depth_map_size: int
      z_far: float
      z_near: float
  # Structure of an individual light cluster
  light_cluster:
    scope: indirect
    fields:
      cell: uint3
      aabb_min: float3
      aabb_max: float3    
      z_range: float2
      visible_light_offset: uint
      visible_light_count: uint
  # All the information required to resolve lighting. This is used by several stages
  # (such as light color/lighting resolve/etc).
  resolve_lighting_parameters:
    scope: draw
    fields:
      light_count: int
      light_buffer: byteaddressbuffer
      light_cluster_buffer: rwbyteaddressbuffer
      light_cluster_visibility_buffer: rwbyteaddressbuffer      
      light_cluster_visibility_count_buffer: rwbyteaddressbuffer      
      shadow_map_count: int
      shadow_map_buffer: byteaddressbuffer
      shadow_map_sampler: sampler
      visualization_mode: int
      light_grid_size: uint3
      uv_scale: float2
      use_constant_ambient: bool
      apply_ambient_lighting: bool
      apply_direct_lighting: bool
      light_probe_grid_count: int
      light_probe_grid_buffer: byteaddressbuffer
      reflection_probe_count: int
      reflection_probe_buffer: byteaddressbuffer     
      brdf_lut: texture2d 
      brdf_lut_sampler: sampler
      ao_enabled: bool
      ao_texture: texture2d
      ao_sampler: sampler
      ao_direct_light_effect: float
      ao_uv_scale: float2
  # Structure describing individual light grids.
  light_probe_grid_state:
    scope: indirect
    fields:
      world_to_grid_matrix: float4x4
      grid_to_world_matrix: float4x4
      size: int3
      bounds: float3
      density: float
      irradiance_texture: texture2d
      occlusion_texture: texture2d
      map_sampler: sampler
      irradiance_texture_size: int 
      irradiance_map_size: int
      irradiance_probes_per_row: int
      occlusion_texture_size: int 
      occlusion_map_size: int
      occlusion_probes_per_row: int
      view_bias: float
      normal_bias: float
      probe_state_buffer: rwbyteaddressbuffer
  # Structure describing individual reflection probes.
  light_probe_state:
    scope: indirect
    fields:
      position_offset: float3
      classification: int
  # Structure describing individual reflection probes.
  reflection_probe_state:
    scope: indirect
    fields:
      world_position: float3
      radius: float
      probe_texture: texturecube
      probe_texture_sampler: sampler
      mip_levels: int
  # Geometry instance
  geometry_instance_info:
    scope: instance
    fields:
      model_matrix: float4x4
      gpu_flags: uint        
  # Param block thats implicitly passed into shaders to define what to render
  vertex_info:
    scope: draw
    fields:
      model_info_table: uint
      model_info_offset: uint
      material_info_table: uint
      material_info_offset: uint
      instance_buffer: byteaddressbuffer
  # Metadata about an instance in the TLAS raytracing structure. Used to lookup
  # model/material/etc information. This is akin to vertex_info from the raster pipeline
  # except it also includes instance information.
  tlas_metadata:
    scope: indirect
    fields:
      model_info_table: uint
      model_info_offset: uint
      material_info_table: uint
      material_info_offset: uint
      gpu_flags: uint
  # Information about a material.
  material_info:
    scope: indirect
    fields:
      domain: int
      albedo_texture: texture2d
      albedo_sampler: sampler
      opacity_texture: texture2d
      opacity_sampler: sampler
      metallic_texture: texture2d
      metallic_sampler: sampler
      roughness_texture: texture2d
      roughness_sampler: sampler
      normal_texture: texture2d
      normal_sampler: sampler   
      skybox_texture: texturecube
      skybox_sampler: sampler  
  # Contains information on all the vertex streams for a given model.
  # Buffers should be checked for validity before being used as any may be omitted.
  model_info:
    scope: indirect
    fields:  
      index_buffer: byteaddressbuffer
      index_size: int
      # These buffers should match k_vertex_stream_runtime_types in model.h
      # They should also match the loading function in global.hlsl
      position_buffer: byteaddressbuffer
      normal_buffer: byteaddressbuffer
      tangent_buffer: byteaddressbuffer
      bitangent_buffer: byteaddressbuffer
      uv0_buffer: byteaddressbuffer
      uv1_buffer: byteaddressbuffer
      uv2_buffer: byteaddressbuffer
      uv3_buffer: byteaddressbuffer
      color0_buffer: byteaddressbuffer
      color1_buffer: byteaddressbuffer
      color2_buffer: byteaddressbuffer
      color3_buffer: byteaddressbuffer

ray_hitgroups:

  # Primitive ray types
  primitive_opaque_hitgroup:
    material_domain: opaque
    ray_type: primitive
    ray_closest_hit_shader: 
      file: data:shaders/source/common/raytracing_primitive_ray.hlsl
      entry: ray_primitive_opaque_closest_hit
  primitive_masked_hitgroup:
    material_domain: masked
    ray_type: primitive
    ray_closest_hit_shader: 
      file: data:shaders/source/common/raytracing_primitive_ray.hlsl
      entry: ray_primitive_masked_closest_hit    
    ray_any_hit_shader: 
      file: data:shaders/source/common/raytracing_primitive_ray.hlsl
      entry: ray_primitive_masked_any_hit
  primitive_transparent_hitgroup:
    material_domain: transparent
    ray_type: primitive
    ray_any_hit_shader: 
      file: data:shaders/source/common/raytracing_primitive_ray.hlsl
      entry: ray_primitive_transparent_any_hit      
  primitive_sky_hitgroup:
    material_domain: sky
    ray_type: primitive
    ray_closest_hit_shader: 
      file: data:shaders/source/common/raytracing_primitive_ray.hlsl
      entry: ray_primitive_sky_closest_hit
      
  # Occlusion ray types
  occlusion_opaque_hitgroup:
    material_domain: opaque
    ray_type: occlusion
    ray_closest_hit_shader: 
      file: data:shaders/source/common/raytracing_occlusion_ray.hlsl
      entry: ray_occlusion_opaque_closest_hit
  occlusion_masked_hitgroup:
    material_domain: masked
    ray_type: occlusion
    ray_closest_hit_shader: 
      file: data:shaders/source/common/raytracing_occlusion_ray.hlsl
      entry: ray_occlusion_masked_closest_hit    
    ray_any_hit_shader: 
      file: data:shaders/source/common/raytracing_occlusion_ray.hlsl
      entry: ray_occlusion_masked_any_hit
  occlusion_transparent_hitgroup:
    material_domain: transparent
    ray_type: occlusion
    ray_any_hit_shader: 
      file: data:shaders/source/common/raytracing_occlusion_ray.hlsl
      entry: ray_occlusion_transparent_any_hit      
  occlusion_sky_hitgroup:
    material_domain: sky
    ray_type: occlusion
    ray_closest_hit_shader: 
      file: data:shaders/source/common/raytracing_occlusion_ray.hlsl
      entry: ray_occlusion_sky_closest_hit

ray_missgroups:

  # Primitive ray types
  primitive_missgroup:
    ray_type: primitive
    ray_miss_shader:
      file: data:shaders/source/common/raytracing_primitive_ray.hlsl
      entry: ray_primitive_miss
      
  # Occlusion ray types
  occlusion_missgroup:
    ray_type: occlusion
    ray_miss_shader:
      file: data:shaders/source/common/raytracing_occlusion_ray.hlsl
      entry: ray_occlusion_miss

defines:
  # The size of the grid the frustum is split into for light culling.
  # Be careful modifying this, you will need to change dispatch rates/etc for
  # the compute shaders as well.
  LIGHT_GRID_SIZE_X: 32 #16
  LIGHT_GRID_SIZE_Y: 18 #9
  LIGHT_GRID_SIZE_Z: 24 #24
  # How many lights can be in each cell in the light grid. Too large and the culling
  # shader will have poor occupancy, too low and you will get artifacts if a lot
  # of lights in the same area.
  MAX_LIGHTS_PER_CLUSTER: 400
  # Over how much distance is a lights contribution faded out as it gets 
  # to its importance distance. Percentage of importance distance.
  LIGHT_IMPORTANCE_FADE_DISTANCE: 0.2
  # Size of each probes irradiance map in the grids atlas.  
  PROBE_GRID_IRRADIANCE_MAP_SIZE: 6
  # Size of each probes occlusion map in the grids atlas.
  PROBE_GRID_OCCLUSION_MAP_SIZE: 14
  # Number of rays per probe that have a fixed orientation to avoid temporal jitter
  # for steps such as relocation.
  PROBE_GRID_FIXED_RAY_COUNT: 32